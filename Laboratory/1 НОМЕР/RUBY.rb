# Функция для проверки, является ли число простым
def is_prime?(n)
  # Числа меньше или равные 1 не являются простыми
  return false if n <= 1
  # Числа 2 и 3 являются простыми
  return true if n <= 3
  # Если число делится на 2 или 3, то оно не является простым
  return false if n % 2 == 0 || n % 3 == 0
  # Проверяем возможные делители от 5 до корня из n
  i = 5
  while i * i <= n
    # Если число делится на i или i + 2, то оно не является простым
    return false if n % i == 0 || n % (i + 2) == 0
    # Переходим к следующему возможному делителю
    i += 6
  end
  # Если мы дошли до этой точки, число является простым
  true
end

# Функция для поиска ближайшего простого числа начиная с заданного числа и шагом
def find_prime(n, step)
  i = n
  # Продолжаем увеличивать i, пока оно не станет простым
  i += step while !is_prime?(i)
  i
end

# Чтение целого числа из стандартного ввода
N = gets.to_i

# Поиск ближайшего правого простого числа
right = find_prime(N, 1)

# Если введенное число N является простым, выводим "0"
if right == N
  puts 0
  return
end

# Иначе, ищем ближайшее левое простое число
left = find_prime(N, -1)

# Выводим минимальную разницу по модулю между N и найденными простыми числами
puts [N - left, N - right].min.abs